{"posts":[{"title":"「JOISC 2016 Day 1」俄罗斯套娃（二维偏序）","content":"「JOISC 2016 Day 1」俄罗斯套娃 思路清奇的呀，先在坐标轴上画图（R为横坐标，H为纵坐标），然后发现每个询问之间没有影响，考虑离线处理，因为询问的要求是选择&gt;=R的，所以把横坐标从大到小排序，二维偏序？，那么在H对应的纵坐标上画一条线，就发现是在这以下的娃娃都满足，然后就树状数组维护不可以套起来的，可以画图理解，就是一个娃娃右上方的，答案是所有不能连接的形成的链的最大值，注意一下更新方式，因为最外面的娃娃也算没有套的，所以就是最大值（真一开始没想通） ","link":"https://lefy959.github.io/post/「JOISC 2016 Day 1」俄罗斯套娃/"},{"title":"CF 1715E - Long Way Home","content":" 又是废掉的一个div2啊 第一次在学校熬夜打cf，开心还看到了自己最喜欢的斜率优化ohhh 链接 ：E - Long Way Home 看到那个平方就可以靠感觉认为是斜率优化了.... 感觉似不似有点想法？？k只有20... 可以试着去考虑最后一步用飞机，然后跑dijkstra求出走普通路径的。 其实就这样了... 考虑k=1的情况： 在最后坐飞机，前面都普通路径行走 则：dnew[i]=min(dold[j]+(i−j)2)d_{new}[i]=min(d_{old}[j]+(i-j)^2)dnew​[i]=min(dold​[j]+(i−j)2) dnewd_{new}dnew​为最后的答案，就是在最后坐飞机，doldd_{old}dold​就是前面已经处理的走普通路径 然后跑一遍dijkstra，看看是否会更新（即假设存在A-&gt;C的最短路径为：A-&gt;B最后坐飞机，B-&gt;C走普通路径） 处理k&gt;1的情况也是一样的，做k次dp，每一次在dp后跑最短路看能否用普通路径更新。 注意的是在一开始要跑一遍最短路，代表坐0次飞机的最短路径。 然后就是对于这个dp式子的处理了： 观察发现可以把式子转换为:dold[j]+j2=2ij+dnew[i]−i2d_{old}[j]+j^2=2ij+d_{new}[i]-i^2dold​[j]+j2=2ij+dnew​[i]−i2 斜率为2i2i2i，X为jjj，Y为dold[j]+j2d_{old}[j]+j^2dold​[j]+j2。斜率和X都单调递增，所以可以画图发现决策点是下凸（为什么不转换式子要画图？因为j有特殊的点） 这个j特殊的点就在于没有范围的限制，也就是范围是(1&lt;=j&lt;=n) 所以就不可以在循环中加入单调队列 可以先一遍循环把所有决策点存入单调队列，然后再一遍循环更新答案 就完了.... 对了！还有一个点：因为m可能小于n，图可能不连通，也就是说从只1号点跑dijkstra就不一定可以遍历完，所以就需要在dp时如果更新了dnewd_{new}dnew​就要把它放入优先队列中，以保证每个点都可以更新到。 Over. 一定要在计算Y的时候把j2j^2j2开成long long啊！！！麻了，改了一个小时(ku) 总的复杂度O(k(mlogn+n))O(k(mlogn+n))O(k(mlogn+n)) 代码: ","link":"https://lefy959.github.io/post/cf-1715e-long-way-home/"},{"title":"「SDOI2016」征途 题解","content":"题目链接 先浅浅复制一个方差 显然dp，可以搞一个🦁 dp[i][j]dp[i][j]dp[i][j]为前i段路程j天到达的最小方差 开始暴力转移 dp[i][j]=min(dp[k][j−1]+?)(j−1≤k≤i−1)dp[i][j]=min(dp[k][j-1]+?)(j-1\\leq k\\leq i-1)dp[i][j]=min(dp[k][j−1]+?)(j−1≤k≤i−1)这咋写？还是需要转换一下🦁 开始了，but题目的方差还需要✖m^2,很好 以下x为m天行走的平均值，s[i]为1~i段路的总路程 那么x可以算对吧:x=s[n]mx=\\frac{s[n]}{m}x=ms[n]​ m×∑i=1m(xi−x)2=m×∑i=1m(xi2+x2−2xxi)=m×(∑i=1mxi2+∑i=1mx2−∑i=1m2xxi)=m×(∑i=1mxi2+s[n]2m−2s[n]m∑i=1mxi)=m×(∑i=1mxi2+s[n]2m−2s[n]2m)=m×(∑i=1mxi2−s[n]2m)=m×∑i=1mxi2−s[n]2m\\times \\sum^m_{i=1}(x_i-x)^2\\\\ =m\\times \\sum^m_{i=1}(x_i^2+x^2-2xx_i)\\\\ =m\\times (\\sum^m_{i=1}x_i^2+\\sum^m_{i=1}x^2-\\sum^m_{i=1}2xx_i)\\\\ =m\\times (\\sum^m_{i=1}x_i^2+\\frac{s[n]^2}{m}-\\frac{2s[n]}{m}\\sum^m_{i=1}x_i)\\\\ =m\\times (\\sum^m_{i=1}x_i^2+\\frac{s[n]^2}{m}-\\frac{2s[n]^2}{m})\\\\ =m\\times (\\sum^m_{i=1}x_i^2-\\frac{s[n]^2}{m})\\\\ =m\\times \\sum^m_{i=1}x_i^2-s[n]^2 m×i=1∑m​(xi​−x)2=m×i=1∑m​(xi2​+x2−2xxi​)=m×(i=1∑m​xi2​+i=1∑m​x2−i=1∑m​2xxi​)=m×(i=1∑m​xi2​+ms[n]2​−m2s[n]​i=1∑m​xi​)=m×(i=1∑m​xi2​+ms[n]2​−m2s[n]2​)=m×(i=1∑m​xi2​−ms[n]2​)=m×i=1∑m​xi2​−s[n]2 是不是感觉快完了推🦁真爽 所以我们似乎只需要维护∑i=1mxi2\\sum^m_{i=1}x_i^2∑i=1m​xi2​最小就好了！ 重新定义dp[i][j]dp[i][j]dp[i][j]为前i段路程分j天到达的每天路程平方的和的最小值 最后答案就应该是dp[n][m]×m−s[n2]dp[n][m]\\times m-s[n^2]dp[n][m]×m−s[n2] 好，开始看状态转移 dp[i][j]=min(dp[k][j−1]+(s[i]−s[k])2)(j−1≤k≤i−1)dp[i][j]=min(dp[k][j-1]+(s[i]-s[k])^2)(j-1\\leq k\\leq i-1)dp[i][j]=min(dp[k][j−1]+(s[i]−s[k])2)(j−1≤k≤i−1)很简单的状态转移，但是复杂度n3n^3n3不接受，好像只有n2n^2n2可以的样子~~（带logloglog的方法就别杠）~~ 那怎么优化？ 我们发现好像是跟s[i]∗s[k]s[i]*s[k]s[i]∗s[k]有关，不能直接单调队列，那斜率优化吧！ dp[i][j]=dp[k][j−1]+(s[i]−s[k])2dp[i][j]=dp[k][j−1]+s[i]2+s[k]2−2s[i]s[k]dp[k][j−1]+s[k]2=2s[i]s[k]−s[i]2−dp[i][j]dp[i][j]=dp[k][j-1]+(s[i]-s[k])^2\\\\ dp[i][j]=dp[k][j-1]+s[i]^2+s[k]^2-2s[i]s[k]\\\\ dp[k][j-1]+s[k]^2=2s[i]s[k]-s[i]^2-dp[i][j]\\\\ dp[i][j]=dp[k][j−1]+(s[i]−s[k])2dp[i][j]=dp[k][j−1]+s[i]2+s[k]2−2s[i]s[k]dp[k][j−1]+s[k]2=2s[i]s[k]−s[i]2−dp[i][j] 点为(s[k],dp[k][j−1]+s[k]2)(s[k],dp[k][j-1]+s[k]^2)(s[k],dp[k][j−1]+s[k]2),斜率就是2s[i]2s[i]2s[i] 然后就是愉快的判断是撒子凸壳的时候了，刚学的 假设k1&gt;k2，并且k1优于k2 dp[k1][j−1]+s[i]2+s[k1]2−2s[i]s[k1]&lt;dp[k2][j−1]+s[i]2+s[k2]2−2s[i]s[k2]dp[k1][j−1]+s[k1]2−dp[k2][j−1]−s[k2]2&lt;2s[i](s[k1]−s[k2])(dp[k1][j−1]+s[k1]2)−(dp[k2][j−1]+s[k2]2)(s[k1]−s[k2])&lt;2s[i]dp[k1][j-1]+s[i]^2+s[k1]^2-2s[i]s[k1]&lt;dp[k2][j-1]+s[i]^2+s[k2]^2-2s[i]s[k2]\\\\ dp[k1][j-1]+s[k1]^2-dp[k2][j-1]-s[k2]^2&lt;2s[i](s[k1]-s[k2])\\\\ \\frac {(dp[k1][j-1]+s[k1]^2)-(dp[k2][j-1]+s[k2]^2)}{(s[k1]-s[k2])}&lt;2s[i] dp[k1][j−1]+s[i]2+s[k1]2−2s[i]s[k1]&lt;dp[k2][j−1]+s[i]2+s[k2]2−2s[i]s[k2]dp[k1][j−1]+s[k1]2−dp[k2][j−1]−s[k2]2&lt;2s[i](s[k1]−s[k2])(s[k1]−s[k2])(dp[k1][j−1]+s[k1]2)−(dp[k2][j−1]+s[k2]2)​&lt;2s[i] 因为是小于，所以是下凸壳，然后就完了噢！ 呼，公式真难打 ","link":"https://lefy959.github.io/post/[SDOI2016]征途/"},{"title":"对于《论信息学竞赛中的学习、方法与态度》的总结摘录","content":"一点小话 其实感觉做记录这个方式挺适合我的，可以知道之前错了什么，也便于总结复习，题目的注释也是，体现思路，便于查错复习 🙏中午读的时候差点给我读哭了，感觉就像是父母语重心长的在安慰鸡汤，我就对这种东西没有一点抵抗力，就有那种你自己都要放弃自己了，但是就总有人在背后支持相信推你，那么为什么不去努力，为什么不去冲一把呢。希望我真正认识到我真正热爱的现在还不晚吧.. 祝我能够拥有良好的拼搏心态，一步步进步，脚踏实地的做每件事，去改变我的人生！ 未来可期！ 正文 为什么大家都揪着直觉了，直觉在思想中是有地位的，套路要见多，要总结经验，进行知识联系，但是终究不能靠这个来提升到较高的成绩 纯粹只找套路的学习没有特别好的效果 成绩波动导致的心情差 正确看待吧，这是暴露问题的方式。如果出现问题要先放正心态，分析问题，解决问题（规则强制约束自己）（毕竟人还是要逼得出来的），紧张是要适度的，平稳发挥就好了，加油吧，相信自己可以逆袭的 心情不好就大哭一场，又如何呢？ 学习需要注意的点 对细节的深入思考——没有刨根问底、缺乏对细节的思考，根本就没有会！ 动手实践 与同伴讲题，讲出来，理解会更深刻，说不定问题想的更明白（我很认同 多问为什么，不要想当然啥都不想深入思考 对问题模型的泛化思考——举一反三；建构知识之间的联系，明白关系 亲手证明思考，理解，分析，讨论，重要的思想和关键的步骤是重要的 能否联想其他的知识，落实在🖊头上 找到方法与节奏——大多数🐂人都是找到了适合自己的学习方法的普通人，那么就是滚雪球越来越好；节奏要看个人了（我觉得），是需要思考细节，是需要泛化思考，但是不是死磕细节，还是要科学一点 摆正心态 这点对谁都很重要吧，兴趣，努力（包括相信自己），学习规律。有一句话：在你眼中别人的努力其实是别人竞赛的兴趣。看的我是真的热泪盈眶，感叹jly的厉害，但是心中怎么会没有一点也想登顶的愿望了，总是害怕自己什么不行，但是其实回过头太这一学期，我改变很多了，我也要相信自己，对吧。我相信我是爱它的，我的竞赛。 学习方法还是要因人而异，记笔记、在记忆最好的时候完成对应的练习，我相信是会达到靠时间堆积不出的效果（小小哔哔几句：我今天中午回去翻到了初一的竞赛笔记本，记得很好我不否认，但是我觉得纸质版对我来说效率可能太低了，而且记起来效率不高，没把重要的地方计全，没有动态更新性，所以似乎我最近（之前也在写）写的《记录》会更适合我） 模仿、改造——找到合适的方法；遇到好的适合自己的就去借鉴学习，但是不是盲目跟从，不适合自己的就不要去学；在书本中寻找答案（前提是我得有时间看）；动态更新 我看见周围的人的学习方式，竞赛文化课，觉得也许很好很努力很有效果，但是真的不一定适合我。我觉得我对外界的抵抗力还是差了一点，这点其实没有什么，反正坚持自己！感觉最近状态不错，效率可以提高，那方法当然会变，更需要把每个题目都打扎实 我看见周围的人的学习方式，竞赛文化课，觉得也许很好很努力很有效果，但是真的不一定适合我。我觉得我对外界的抵抗力还是差了一点，这点其实没有什么，反正坚持自己！感觉最近状态不错，效率可以提高，那方法当然会变，更需要把每个题目都打扎实 稳扎稳打 对最坏的结局也要接受，但是要争取下次进步，不是争取，是必须，哪怕是对自己的。 ","link":"https://lefy959.github.io/post/《论信息学竞赛中的学习、方法与态度》的总结摘录/"},{"title":"「POJ 3666」Making the Grade 题解（两种做法）","content":"0前言 感谢yxy童鞋的dp及暴力做法！ 1 算法标签 优先队列、dp动态规划+滚动数组优化 2 题目难度 提高/提高+ CF rating：2300 3 题面 「POJ 3666」Making the Grade 路面修整 4 分析题面 4.1 简要描述 给出数列 AAA, 求非严格单调不上升或单调不下降, 且S=∑i=1N∣Ai−Bi∣S=\\sum^N_{i=1}|A_i-B_i|S=∑i=1N​∣Ai​−Bi​∣ 最小的序列BBB，输出SSS 4.2 模型转换 输入NNN, 然后输入NNN个数，求最小的改动这些数使之成非严格递增或非严格递减即可 5 问题分析 以B为非严格单调递增为例 5.0 暴力 我们直接当考虑已经选了nnn个数： 若n=1，A1=B1n=1，A_1=B_1n=1，A1​=B1​时S最小为∣A1−B1∣|A_1-B_1|∣A1​−B1​∣ 若n&gt;1n&gt;1n&gt;1，前面已经选择了n-1个数，取得了最小值，考虑怎么取第n个数 若 Ai≥Bi−1A_i≥B_{i-1}Ai​≥Bi−1​，Bi=AiB_i=A_iBi​=Ai​显然最优 若Ai&lt;Bi−1A_i&lt; B_{i-1}Ai​&lt;Bi−1​ Bi=AiB_i=A_iBi​=Ai​ 将Bk,BK+1,...,BiB_k,B_{K+1},...,B_iBk​,BK+1​,...,Bi​都赋值为Ak,Ak+1,...,AiA_k,A_k+1,...,A_iAk​,Ak​+1,...,Ai​的中位数 口胡证明： 我们可以将Bk,BK+1,...,BiB_k,B_{K+1},...,B_iBk​,BK+1​,...,Bi​标记在数轴上 再将Ak,Ak+1,...,AiA_k,A_k+1,...,A_iAk​,Ak​+1,...,Ai​标记上 那么，其实S的几何含义就是每一组AiA_iAi​到BiB_iBi​的距离之和 我们的小学数学也学过绝对值最值问题： 求∣x−k1∣+∣x−k2∣+∣x−k3∣...|x-k_1|+|x-k_2|+|x-k_3|...∣x−k1​∣+∣x−k2​∣+∣x−k3​∣...的最小值 其实和这里的SSS是没有任何区别的 所以，我们知道零点分段法可以解决这类问题 就是取中位数（就是使每个绝对值内部为0的x答案数组的中位数） 可以使得绝对值之和最小 如果xxx在两个kkk之间,那么无论xxx在哪,距离之和都是这两个kkk的距离 如果在这两个kkk之外,那么距离之和则为两个kkk距离加上两倍的xxx距近的kkk的距离，肯定不会优于于第一种情况 那么我们只要尽量让xxx在越多的kkk之间即可 那么最佳解xxx在图中就是444,如果kkk的个数为偶数nnn,则是kn/2和Kn/2+1k_{n/2}和K_{n/2+1}kn/2​和Kn/2+1​之间 综上，选择中位数最佳 5.1 法一 dp（动态规划） 通过综上分析(5.0中)，我们直接暴力模拟肯定是不行的~~（这个复杂度直接爆掉了）~~ 但是！ 我们可以从中得到一个veryveryvery importantimportantimportant的结论： BBB数列中的每个数必定都为AAA数列中的元素 所以，我们可以考虑用dpdpdp来解决： 阶段：到第iii位 状态：dpi,jdp_{i,j}dpi,j​表示以BjB_jBj​结尾的SminS_{min}Smin​ B数组是A的复制排序处理过后的数组 $\\space \\space $ dp[i][j]dp[i][j]dp[i][j]表示把前i个数变成不严格单调递增且第iii个数变成原来第jjj大的数的最小代价 转移方程：dpi,j=min(dpi−1,k)+∣Ai−Bj∣,其中1≤j≤n,1≤k≤jdp_{i,j}=min(dp_{i-1,k})+|A_i-B_j|,其中1≤j≤n,1≤k≤jdpi,j​=min(dpi−1,k​)+∣Ai​−Bj​∣,其中1≤j≤n,1≤k≤j 5.2 法二 堆（优先队列） 5.2.1 内心思考 现在我们可以重新想一下，既然是需要求非严格单调递增，那么重要的是什么呢？ 当前序列的最大值。（这一点应该是肯定的） 最大值？ 是不是有什么奇怪的想法了？ ... 堆！ 所以就简单搞个大根堆吧！ 5.2.2 模拟过程 begin... $\\space \\space \\space \\space \\space \\space $数据 ：1 3 2 4 5 3 9 i=1: \\space \\space \\space \\space \\space 堆：空，a[i]=1，top=空 这个时候堆是空的，肯定要放进去 \\space \\space \\space \\space \\space \\space ∴把a[i]放入堆中 \\space \\space \\space \\space \\space \\space -&gt;堆：1 ，a[i]=1，top=1 i=2: \\space \\space \\space \\space \\space \\space 堆：1 ，a[i]=3，top=1 这个时候a[i]&gt;top，就是说明满足非严格单调递增 \\space \\space \\space \\space \\space \\space ∴把a[i]放入堆中 \\space \\space \\space \\space \\space \\space -&gt;堆：3 1 ，a[i]=3，top=3 i=3: \\space \\space \\space \\space \\space \\space 堆：3 1 ，a[i]=2，top=3 这个时候a[i]&lt;top，说明已经不满足非严格单调递增了，那么就需要修改top或者是a[i]的值 最节省的方法肯定花费top-a[i]来进行更改 更改后会得到(a[i],a[i]),(a[i]+1,a[i]+1)....(top-1,top-1),(top,top)这些二元组 这里面肯定是有合法的二元组，肯定也是有不合法的 再引入一个变量：newtop:当前top被pop掉过后的top 我们可以肯定，在上面所有的二元组当中，是有可以满足值≥newtop的，所以这对二元组是一定可以满足非严格单调递增，那么后面的数据也只需要满足数值≥newtop就可以了 所以我们就需要使得这对二元组的数值尽量不对后面的操作产生影响，那么就放入两个最小值，即a[i]。 \\space \\space \\space \\space \\space \\space ∴把top给pop掉，a[i]和a[i]放入堆中 \\space \\space \\space \\space \\space \\space -&gt;堆：2 2 1 ，a[i]=2，top=2 这个时候放入两个a[i]是合法的，那么我们就来看一种放入两个a[i]不合法的情况 ... i=6 \\space \\space \\space \\space \\space \\space 堆：5 4 2 2 1 ，a[i]=3，top=5 按照我们之前讨论的操作进行过后，会是 \\space \\space \\space \\space \\space \\space 堆：4 3 3 2 2 1 ，a[i]=3，top=4 \\space \\space \\space \\space \\space \\space 原序列: 1 2 2 4 3 3 这个时候我们可以发现如果是把a[5]改成3，在原序列看上去是不合法的，但是这问题大吗？ 不大。 因为我们更改过后的二元组不一定非是3 3，它也可以是4 4，5 5，那么这样就是合法的了，我们把3丢进去的原因就是为了尽量不影响后面的操作，让后面要是进行变化也会变得尽量小，更好维护非严格单调递增 5.2.3 总结 也就是说，我们需要明确，堆里面存的可能不是最终的序列，它里面存的就是当前序列需要满足的最小值。 6 实现细节 6.1 法一：dp（动态规划） 6.1.1 滚动数组 从我们的dpdpdp方程：dpi,j=min(dpi−1,k)+∣Ai−Bj∣,其中1≤j≤n,1≤k≤jdp_{i,j}=min(dp_{i-1,k})+|A_i-B_j|,其中1≤j≤n,1≤k≤jdpi,j​=min(dpi−1,k​)+∣Ai​−Bj​∣,其中1≤j≤n,1≤k≤j 灰常容易地阔以算出空间复杂度是O(n2)O(n^2)O(n2) 这个。。秉承着我们能省则省的原则 看到这个开二维数组O(n2)O(n^2)O(n2)的空间貌似有点浪费 那怎么去优化空间呢？ 又由于我们的dpdpdp方程中只用到了i−1i-1i−1的信息 于是我们下意识地反应： ——用滚动数组优化！ \\space \\space 用位运算符&amp;来记录，这样就只用了0/10/10/1来表示 重复利用，节省空间 \\space\\space\\space\\space iii&amp;111的效果和iii%222的效果是一样的，但是iii&amp;111要快一点 \\space\\space\\space\\space 且这种方式比直接写0/10/10/1少了一个不断交换的过程 \\space\\space\\space\\space 窝jio得这个东西还是很·····香的 将i−&gt;ii-&gt;ii−&gt;i &amp; 111，i−1−&gt;(i−1)i-1-&gt;(i-1)i−1−&gt;(i−1)&amp;111 方程就变成了这样： dp[idp[idp[i&amp;1][j]=min(dp[(i−1)1][j]=min(dp[(i-1)1][j]=min(dp[(i−1)&amp;][k])+∣A[i]−B[j]∣,其中1≤j≤n,1≤k≤j][k])+|A[i]-B[j]|,其中1≤j≤n,1≤k≤j][k])+∣A[i]−B[j]∣,其中1≤j≤n,1≤k≤j 6.1.2 最小值 但是这个复杂度。。 看上去好像是3层循环，就是O(n3)O(n^3)O(n3)啊 在n&lt;=2000n&lt;=2000n&lt;=2000 的时候就已经game overgame\\space overgame over了，显然不行啊 这个xiao问题应该有手就行吧 其实只要一边更新min(f[i−1][k])min(f[i-1][k])min(f[i−1][k])一般算当前的f[i][j]f[i][j]f[i][j]就行 （因为kkk只到jjj） 6.1.3 降序 不严格单调不上升的情况也一样 更加方便的是可以把BBB数组从大到小排序后，做单调不下降的dp就🆗了 6.1.4 时间复杂度 二维DP，所以就是O(n2)O(n^2)O(n2) 6.2 法二 堆（优先队列） 6.2.1 具体操作 以非严格单调递增为例 搞一个大根堆，依次遍历数组 当堆为空的时候直接pushpushpush 当a[i]≥topa[i]≥topa[i]≥top的时候直接pushpushpush 当a[i]&lt;topa[i]&lt; topa[i]&lt;top的时候，ans+=top-a[i]，先pop再push两次a[i]（一个用来代替原pop，一个是本身） 那非严格单调递减就是相反的了 最后把两种的ansansans去一个minminmin就好了 6.2.2 时间复杂度 堆的一堆操作，所以就是O(nlogn)O(nlogn)O(nlogn) 7 代码实现 7.1 法一：dp（动态规划） 7.2 法二：堆（优先队列） 十分简单清晰明了 8 总结 最大的收获：就算做不出来也需要想一些可能的做法，说不定就撞对了 新鲜的知识：更优秀的滚动数组写法|堆的奇妙用法 相似的题目：CF #371 div.1 C Sonya and Problem Wihtout a Legend ","link":"https://lefy959.github.io/post/「POJ 3666」Making the Grade/"},{"title":"「APIO2010」巡逻 题解","content":"1 题面 「APIO2010」巡逻 大意：有一个有n个节点的树，每条边权为1，一每天要从1号点开始，遍历所有的边，再回到1号点，每条道路都经过两次，为了减少需要走的距离，可以增加K(1≤K≤2)(1\\leq K\\leq 2)(1≤K≤2)条新的边（可以自环），且每天必须经过这K条边正好一次，请计算最佳方案是总路程最小，并输出最小值 2 分析题面 因为K很小，所以我们可以试着手推一下每种情况 2.1 不加边 从1号点出发，要把每个边遍历一遍再回到1号点，会恰好经过每条边2次，经过的路线总长为2(n-1)。 2.2 加1条边 因为这是一棵树，我们加一条边就会使它变成环，这个环便可以在遍历图的时候减少重复遍历的长度 如： 观察可以发现，在2和8之间加一条边后，2~8的路径经过的次数就会减一，加上新的这条边的边权，所以对应的，总的需要经过的路径总长度也会改变 那么也能很显然的看出，我们要尽量选择隔得远的两个节点建边，可以使得节省的路径更长 换个说法：找到树上距离最长的两点 于是，是不是想到了什么？ 对，树的直径 那这样我们就可以用树的直径来求出两个距离最长节点，在他们之间建一条边，然后用lca算出他们的路径长度dist1，答案就应该是2(n−1)−dist1+12(n-1)-dist1+12(n−1)−dist1+1 那么这样，我们也就拿到了30分 2.3 加两条边 第一条边加完了，再各种手推的加第二条边的情况 2.3.1 两个环有重叠 ​ 两环重叠部分1-3-5-8，长度为3；车子还要跑正好一遍1-8这条新路，就导致1-3-5-8要多走一遍，多增加了4的长度 肯定不行！ 所以我们要让它的重叠部分长度为0（不然还不如自环）！ 2.3.2 两个环无重叠 那就没有多跑的影响，如： 2.3.3 如何计算 那应该怎么计算多在哪里建一条边呢？ 经过我们之前的推导，肯定也是在直径上，但是我们这里要不让它有重叠，也就是说，直径上的路径不应该有之前第一次直径的路径，所以就可以考虑把之前直径的路径的边权变为-1，在跑一次直径就ok了,长度记为dist2 那么答案就应该是2(n−1)−dist1−dist2+22(n-1)-dist1-dist2+22(n−1)−dist1−dist2+2 2.4 时间复杂度 第一次直径O(n),修改边权O(n),第二次直径O(n) 噢，O(n)的整体算法！ 3 代码实现（注释） 3.0 树的直径 考虑到我一开始都忘了这个知识点，还是简单补充一下吧 这道题的一个最直观的考点——树的直径 树的直径简单来说就是树中最长的链，下面将有两种O(n)的方法来求树的直径。 背景：假设树以N个节点N-1条边以无向图的形式给出并以邻接表的形式给出。 第一种：树形DP求树的直径 我们用dis[x]表示x节点到叶子节点的最大值（单方面往下） 看不懂转移的可以自己推一下很显然 代码实现： 优点：可以处理负权值的问题（就比如我们这里的第二条直径） 但是缺点就是不好记录直径的起始点和终结点和路径~~（也可能是我太逊~~ 第二种：两次dfs(bfs)求直径 方法：先从任意一点P出发，找离它最远的点Q，再从点Q出发，找离它最远的点W，W到Q的距离就是是的直径 （我不想写证明！） 证明： 若P已经在直径上，根据树的直径的定义可知Q也在直径上且为直径的一个端点 若P不在直径上，我们用反证法，假设此时WQ不是直径，AB是直径 若AB与PQ有交点C，由于P到Q最远，那么PC+CQ&gt;PC+CA，所以CQ&gt;CA，易得CQ+CB&gt;CA+CB，即CQ+CB&gt;AB，与AB是直径矛盾，不成立，如图： ​ 若AB与PQ没有交点，M为AB上任意一点，N为PQ上任意一点。首先还是NP+NQ&gt;NQ+MN+MB，同时减掉NQ，得NP&gt;MN+MB，易知NP+MN&gt;MB，所以NP+MN+MA&gt;MB+MA，即NP+MN+MA&gt;AB，与AB是直径矛盾，所以这种情况也不成立： ​ 代码： 优点：很容易记录直径的两个端点和路径 缺点：无法处理负边权 3.1定义 3.2 输入 3.3 计算 3.3.1 求第一条直径 这里面第二次计算后l1的值就是直径的长度，当然知道了两个节点你也可以用lca求（有什么必要呢） 3.3.2 修改边权 因为第二次dfs完后的根节点就是第一条直径其中的一个端点，所以直径一定是另一个端点到根节点的路径 注意：这里是需要把两条边都修改为-1，我在这里wa了好久！ 3.3.3 求第二条直径的长度 我一开始一直在搞两个dfs的方法，后面静态调试才发现不对（再次声明两次dfs的方法不可以处理负边权！！） 树形dp就好了，这个可以处理负边权 3.4 输出 3.5 总体代码 ","link":"https://lefy959.github.io/post/「APIO2010」巡逻/"}]}